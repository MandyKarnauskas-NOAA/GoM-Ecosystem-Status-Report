plot(c(1:N_ts)[abs(Z_rot[, i]) > minZ], as.vector(Z_rot[abs(Z_rot[, i]) > minZ, i]), type = "h", lwd = 2,
xlab = "", ylab = "", xaxt = "n", ylim=ylm, xlim = c(0.5, N_ts + 0.5), col = clr)
axis(1, at=1:N_ts, lab=ylbl, las=2,)
abline(h = 0, lwd = 1.5, col = "gray")
mtext(paste("Factor loadings on state", i), side = 3, line = 0.5)
}
layout(matrix(c(1:(mm*2)), mm, 2), widths = c(2, 1.5))
## par(mfcol=c(mm,2), mai=c(0.5,0.5,0.5,0.1), omi=c(0,0,0,0))
par(mai = c(0.5, 0.5, 0.5, 0.1), omi = c(0, 0, 0, 0))
clr <- rainbow(8, start=0.4, end=0.9)
## plot the processes
for (i in 1:mm) {
ylm <- c(-1, 1) * max(abs(proc_rot[i, ]))
## set up plot area
plot(w_ts, proc_rot[i, ], type = "n", bty = "L", ylim = ylm,
xlab = "", ylab = "", xaxt = "n")
## draw zero-line
abline(h = 0, col = "gray")
## plot trend line
lines(w_ts, proc_rot[i, ], lwd = 2)
lines(w_ts, proc_rot[i, ], lwd = 2)
## add panel labels
mtext(paste("State", i), side = 3, line = 0.5)
axis(1, at=w_ts, lab=d$Year)
}
## plot the loadings
minZ <- 0
ylm <- c(-1, 1) * max(abs(Z_rot))
par(mar=c(7, 2, 2, 0.5))
for (i in 1:mm) {
plot(c(1:N_ts)[abs(Z_rot[, i]) > minZ], as.vector(Z_rot[abs(Z_rot[, i]) > minZ, i]), type = "h", lwd = 2,
xlab = "", ylab = "", xaxt = "n", ylim=ylm, xlim = c(0.5, N_ts + 0.5), col = clr)
axis(1, at=1:N_ts, lab=ylbl, las=2,)
abline(h = 0, lwd = 1.5, col = "gray")
mtext(paste("Factor loadings on state", i), side = 3, line = 0.5)
}
RR
get_DFA_fits <- function(MLEobj, dd = NULL, alpha = 0.05) {
## empty list for results
fits <- list()
## extra stuff for var() calcs
Ey <- MARSS:::MARSShatyt(MLEobj)
## model params
ZZ <- coef(MLEobj, type = "matrix")$Z
## number of obs ts
nn <- dim(Ey$ytT)[1]
## number of time steps
TT <- dim(Ey$ytT)[2]
## get the inverse of the rotation matrix
H_inv <- varimax(ZZ)$rotmat
## check for covars
if (!is.null(dd)) {
DD <- coef(MLEobj, type = "matrix")$D
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states + DD %*% dd
} else {
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states
}
## Var in model fits
VtT <- MARSSkfss(MLEobj)$VtT
VV <- NULL
for (tt in 1:TT) {
RZVZ <- coef(MLEobj, type = "matrix")$R - ZZ %*% VtT[,
, tt] %*% t(ZZ)
SS <- Ey$yxtT[, , tt] - Ey$ytT[, tt, drop = FALSE] %*%
t(MLEobj$states[, tt, drop = FALSE])
VV <- cbind(VV, diag(RZVZ + SS %*% t(ZZ) + ZZ %*% t(SS)))
}
SE <- sqrt(VV)
## upper & lower (1-alpha)% CI
fits$up <- qnorm(1 - alpha/2) * SE + fits$ex
fits$lo <- qnorm(alpha/2) * SE + fits$ex
return(fits)
}
## get model fits & CI's
mod_fit <- get_DFA_fits(dfa_1)
## plot the fits
par(mfrow = c(4,2), mai = c(0.5, 0.7, 0.1, 0.1), omi = c(0, 0, 0, 0))
for (i in 1:N_ts) {
up <- mod_fit$up[i, ]
mn <- mod_fit$ex[i, ]
lo <- mod_fit$lo[i, ]
plot(w_ts, mn, xlab = "", ylab = ylbl[i], xaxt = "n", type = "n",
cex.lab = 1.2, ylim = c(min(lo), max(up)))
axis(1, at=w_ts, d$Year)
points(w_ts, dat[i, ], pch = 16, col = i)
lines(w_ts, up, col = "darkgray")
lines(w_ts, mn, col = "black", lwd = 2)
lines(w_ts, lo, col = "darkgray")
}
dfa_1
## get model fits & CI's
mod_fit <- get_DFA_fits(dfa_1)
## plot the fits
par(mfrow = c(4,2), mai = c(0.5, 0.7, 0.1, 0.1), omi = c(0, 0, 0, 0))
for (i in 1:N_ts) {
up <- mod_fit$up[i, ]
mn <- mod_fit$ex[i, ]
lo <- mod_fit$lo[i, ]
plot(w_ts, mn, xlab = "", ylab = ylbl[i], xaxt = "n", type = "n",
cex.lab = 1.2, ylim = c(min(lo), max(up)))
axis(1, at=w_ts, d$Year)
points(w_ts, dat[i, ], pch = 16, col = clr[i])
lines(w_ts, up, col = "darkgray")
lines(w_ts, mn, col = "black", lwd = 2)
lines(w_ts, lo, col = "darkgray")
}
m
mm
RR
rm(list=ls())
library(MARSS)
## load the data
d <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/birdPA.csv", header=T, sep=",")
co <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/covars.csv", header=T, sep=",")
co <- co[which(co$Year <= max(d$Year) & co$Year >= min(d$Year)),]
## transpose data so time goes across columns
d[2:9] <- scale(d[2:9])
dat <- t(d[2:9])
## get number of time series
N_ts <- dim(dat)[1]
## get length of time series
TT <- dim(dat)[2]
## 'ZZ' is loadings matrix
Z_vals <- list("z11", 0, 0, 0, "z21", "z22", 0, 0, "z31", "z32", "z33", 0,
"z41", "z42", "z43", "z44", "z51", "z52", "z53", "z54", "z61",
"z62", "z63", "z64","z71", "z72", "z73", "z74","z81", "z82", "z83", "z84")
ZZ <- matrix(Z_vals, nrow = N_ts, ncol = 4, byrow = TRUE)
ZZ
## 'aa' is the offset/scaling
aa <- "zero"
## 'DD' and 'd' are for covariates
DD <- "zero"  # matrix(0,mm,1)
dd <- "zero"  # matrix(0,1,wk_last)
## 'RR' is var-cov matrix for obs errors
RR <- "diagonal and equal"
## number of processes
mm <- 2
ZZ <- ZZ[,1:mm]
## 'BB' is identity: 1's along the diagonal & 0's elsewhere
BB <- "identity"  # diag(mm)
## 'uu' is a column vector of 0's
uu <- "zero"  # matrix(0,mm,1)
## 'CC' and 'cc' are for covariates
CC <- "zero"  # matrix(0,mm,1)
cc <- "zero"  # matrix(0,1,wk_last)
## 'QQ' is identity
QQ <- "identity"  # diag(mm)
## list with specifications for model vectors/matrices
mod_list <- list(Z = ZZ, A = aa, D = DD, d = dd, R = RR, B = BB,
U = uu, C = CC, c = cc, Q = QQ)
## list with model inits
init_list <- list(x0 = matrix(rep(0, mm), mm, 1))
## list with model control parameters
con_list <- list(maxit = 3000, allow.degen = TRUE)
## fit MARSS
dfa_1 <- MARSS(y = dat, model = mod_list, inits = init_list, control = con_list)
slr <- t(co[, "SLR", drop = FALSE])
men <- t(co[, "menhadenYOY", drop = FALSE])
sst <- t(co[, "SST", drop = FALSE])
sst[1:2] <- sst[3]
mod_list = list(m = 2, R = "diagonal and equal")
dfa_slr <- MARSS(dat, model=mod_list, form="dfa", z.score=FALSE,  control=con_list, covariates= slr)
mm; RR
dfa_1<- dfa_slr
dfa_1
## get the estimated ZZ
Z_est <- coef(dfa_1, type = "matrix")$Z
## get the inverse of the rotation matrix
H_inv <- varimax(Z_est)$rotmat
## rotate factor loadings
Z_rot = Z_est %*% H_inv
## rotate processes
proc_rot = solve(H_inv) %*% dfa_1$states
ylbl <- rownames(dat)
w_ts <- seq(dim(dat)[2])
layout(matrix(c(1:(mm*2)), mm, 2), widths = c(2, 1.5))
## par(mfcol=c(mm,2), mai=c(0.5,0.5,0.5,0.1), omi=c(0,0,0,0))
par(mai = c(0.5, 0.5, 0.5, 0.1), omi = c(0, 0, 0, 0))
clr <- rainbow(8, start=0.4, end=0.9)
## plot the processes
for (i in 1:mm) {
ylm <- c(-1, 1) * max(abs(proc_rot[i, ]))
## set up plot area
plot(w_ts, proc_rot[i, ], type = "n", bty = "L", ylim = ylm,
xlab = "", ylab = "", xaxt = "n")
## draw zero-line
abline(h = 0, col = "gray")
## plot trend line
lines(w_ts, proc_rot[i, ], lwd = 2)
lines(w_ts, proc_rot[i, ], lwd = 2)
## add panel labels
mtext(paste("State", i), side = 3, line = 0.5)
axis(1, at=w_ts, lab=d$Year)
}
## plot the loadings
minZ <- 0
ylm <- c(-1, 1) * max(abs(Z_rot))
par(mar=c(7, 2, 2, 0.5))
for (i in 1:mm) {
plot(c(1:N_ts)[abs(Z_rot[, i]) > minZ], as.vector(Z_rot[abs(Z_rot[, i]) > minZ, i]), type = "h", lwd = 2,
xlab = "", ylab = "", xaxt = "n", ylim=ylm, xlim = c(0.5, N_ts + 0.5), col = clr)
axis(1, at=1:N_ts, lab=ylbl, las=2,)
abline(h = 0, lwd = 1.5, col = "gray")
mtext(paste("Factor loadings on state", i), side = 3, line = 0.5)
}
get_DFA_fits <- function(MLEobj, dd = NULL, alpha = 0.05) {
## empty list for results
fits <- list()
## extra stuff for var() calcs
Ey <- MARSS:::MARSShatyt(MLEobj)
## model params
ZZ <- coef(MLEobj, type = "matrix")$Z
## number of obs ts
nn <- dim(Ey$ytT)[1]
## number of time steps
TT <- dim(Ey$ytT)[2]
## get the inverse of the rotation matrix
H_inv <- varimax(ZZ)$rotmat
## check for covars
if (!is.null(dd)) {
DD <- coef(MLEobj, type = "matrix")$D
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states + DD %*% dd
} else {
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states
}
## Var in model fits
VtT <- MARSSkfss(MLEobj)$VtT
VV <- NULL
for (tt in 1:TT) {
RZVZ <- coef(MLEobj, type = "matrix")$R - ZZ %*% VtT[,
, tt] %*% t(ZZ)
SS <- Ey$yxtT[, , tt] - Ey$ytT[, tt, drop = FALSE] %*%
t(MLEobj$states[, tt, drop = FALSE])
VV <- cbind(VV, diag(RZVZ + SS %*% t(ZZ) + ZZ %*% t(SS)))
}
SE <- sqrt(VV)
## upper & lower (1-alpha)% CI
fits$up <- qnorm(1 - alpha/2) * SE + fits$ex
fits$lo <- qnorm(alpha/2) * SE + fits$ex
return(fits)
}
## get model fits & CI's
mod_fit <- get_DFA_fits(dfa_1)
## plot the fits
par(mfrow = c(4,2), mai = c(0.5, 0.7, 0.1, 0.1), omi = c(0, 0, 0, 0))
for (i in 1:N_ts) {
up <- mod_fit$up[i, ]
mn <- mod_fit$ex[i, ]
lo <- mod_fit$lo[i, ]
plot(w_ts, mn, xlab = "", ylab = ylbl[i], xaxt = "n", type = "n",
cex.lab = 1.2, ylim = c(min(lo), max(up)))
axis(1, at=w_ts, d$Year)
points(w_ts, dat[i, ], pch = 16, col = clr[i])
lines(w_ts, up, col = "darkgray")
lines(w_ts, mn, col = "black", lwd = 2)
lines(w_ts, lo, col = "darkgray")
}
mm
R
RR
rm(list=ls())
library(MARSS)
## load the data
d <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/birdPA.csv", header=T, sep=",")
co <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/covars.csv", header=T, sep=",")
co <- co[which(co$Year <= max(d$Year) & co$Year >= min(d$Year)),]
## transpose data so time goes across columns
d[2:9] <- scale(d[2:9])
dat <- t(d[2:9])
## get number of time series
N_ts <- dim(dat)[1]
## get length of time series
TT <- dim(dat)[2]
## 'ZZ' is loadings matrix
Z_vals <- list("z11", 0, 0, 0, "z21", "z22", 0, 0, "z31", "z32", "z33", 0,
"z41", "z42", "z43", "z44", "z51", "z52", "z53", "z54", "z61",
"z62", "z63", "z64","z71", "z72", "z73", "z74","z81", "z82", "z83", "z84")
ZZ <- matrix(Z_vals, nrow = N_ts, ncol = 4, byrow = TRUE)
ZZ
## 'aa' is the offset/scaling
aa <- "zero"
## 'DD' and 'd' are for covariates
DD <- "zero"  # matrix(0,mm,1)
dd <- "zero"  # matrix(0,1,wk_last)
## 'RR' is var-cov matrix for obs errors
RR <- "diagonal and unequal"
## number of processes
mm <- 2
ZZ <- ZZ[,1:mm]
## 'BB' is identity: 1's along the diagonal & 0's elsewhere
BB <- "identity"  # diag(mm)
## 'uu' is a column vector of 0's
uu <- "zero"  # matrix(0,mm,1)
## 'CC' and 'cc' are for covariates
CC <- "zero"  # matrix(0,mm,1)
cc <- "zero"  # matrix(0,1,wk_last)
## 'QQ' is identity
QQ <- "identity"  # diag(mm)
## list with specifications for model vectors/matrices
mod_list <- list(Z = ZZ, A = aa, D = DD, d = dd, R = RR, B = BB,
U = uu, C = CC, c = cc, Q = QQ)
## list with model inits
init_list <- list(x0 = matrix(rep(0, mm), mm, 1))
## list with model control parameters
con_list <- list(maxit = 3000, allow.degen = TRUE)
## fit MARSS
dfa_1 <- MARSS(y = dat, model = mod_list, inits = init_list, control = con_list)
mm
RR
mm; RR
## get the estimated ZZ
Z_est <- coef(dfa_1, type = "matrix")$Z
## get the inverse of the rotation matrix
H_inv <- varimax(Z_est)$rotmat
## rotate factor loadings
Z_rot = Z_est %*% H_inv
## rotate processes
proc_rot = solve(H_inv) %*% dfa_1$states
ylbl <- rownames(dat)
w_ts <- seq(dim(dat)[2])
layout(matrix(c(1:(mm*2)), mm, 2), widths = c(2, 1.5))
## par(mfcol=c(mm,2), mai=c(0.5,0.5,0.5,0.1), omi=c(0,0,0,0))
par(mai = c(0.5, 0.5, 0.5, 0.1), omi = c(0, 0, 0, 0))
clr <- rainbow(8, start=0.4, end=0.9)
## plot the processes
for (i in 1:mm) {
ylm <- c(-1, 1) * max(abs(proc_rot[i, ]))
## set up plot area
plot(w_ts, proc_rot[i, ], type = "n", bty = "L", ylim = ylm,
xlab = "", ylab = "", xaxt = "n")
## draw zero-line
abline(h = 0, col = "gray")
## plot trend line
lines(w_ts, proc_rot[i, ], lwd = 2)
lines(w_ts, proc_rot[i, ], lwd = 2)
## add panel labels
mtext(paste("State", i), side = 3, line = 0.5)
axis(1, at=w_ts, lab=d$Year)
}
## plot the loadings
minZ <- 0
ylm <- c(-1, 1) * max(abs(Z_rot))
par(mar=c(7, 2, 2, 0.5))
for (i in 1:mm) {
plot(c(1:N_ts)[abs(Z_rot[, i]) > minZ], as.vector(Z_rot[abs(Z_rot[, i]) > minZ, i]), type = "h", lwd = 2,
xlab = "", ylab = "", xaxt = "n", ylim=ylm, xlim = c(0.5, N_ts + 0.5), col = clr)
axis(1, at=1:N_ts, lab=ylbl, las=2,)
abline(h = 0, lwd = 1.5, col = "gray")
mtext(paste("Factor loadings on state", i), side = 3, line = 0.5)
}
get_DFA_fits <- function(MLEobj, dd = NULL, alpha = 0.05) {
## empty list for results
fits <- list()
## extra stuff for var() calcs
Ey <- MARSS:::MARSShatyt(MLEobj)
## model params
ZZ <- coef(MLEobj, type = "matrix")$Z
## number of obs ts
nn <- dim(Ey$ytT)[1]
## number of time steps
TT <- dim(Ey$ytT)[2]
## get the inverse of the rotation matrix
H_inv <- varimax(ZZ)$rotmat
## check for covars
if (!is.null(dd)) {
DD <- coef(MLEobj, type = "matrix")$D
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states + DD %*% dd
} else {
## model expectation
fits$ex <- ZZ %*% H_inv %*% MLEobj$states
}
## Var in model fits
VtT <- MARSSkfss(MLEobj)$VtT
VV <- NULL
for (tt in 1:TT) {
RZVZ <- coef(MLEobj, type = "matrix")$R - ZZ %*% VtT[,
, tt] %*% t(ZZ)
SS <- Ey$yxtT[, , tt] - Ey$ytT[, tt, drop = FALSE] %*%
t(MLEobj$states[, tt, drop = FALSE])
VV <- cbind(VV, diag(RZVZ + SS %*% t(ZZ) + ZZ %*% t(SS)))
}
SE <- sqrt(VV)
## upper & lower (1-alpha)% CI
fits$up <- qnorm(1 - alpha/2) * SE + fits$ex
fits$lo <- qnorm(alpha/2) * SE + fits$ex
return(fits)
}
## get model fits & CI's
mod_fit <- get_DFA_fits(dfa_1)
## plot the fits
par(mfrow = c(4,2), mai = c(0.5, 0.7, 0.1, 0.1), omi = c(0, 0, 0, 0))
for (i in 1:N_ts) {
up <- mod_fit$up[i, ]
mn <- mod_fit$ex[i, ]
lo <- mod_fit$lo[i, ]
plot(w_ts, mn, xlab = "", ylab = ylbl[i], xaxt = "n", type = "n",
cex.lab = 1.2, ylim = c(min(lo), max(up)))
axis(1, at=w_ts, d$Year)
points(w_ts, dat[i, ], pch = 16, col = clr[i])
lines(w_ts, up, col = "darkgray")
lines(w_ts, mn, col = "black", lwd = 2)
lines(w_ts, lo, col = "darkgray")
}
rm(list=ls())
library(MARSS)
## load the data
d <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/birdPA.csv", header=T, sep=",")
co <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/covars.csv", header=T, sep=",")
co
head(co)
plot(co$Year, co$SLR)
plot(co$Year, co$SLR, type="l")
plot(co$Year, co$SLR, type="l", xlab="year", ylab="sea level rise")
plot(co$Year, co$SST)
plot(co$Year, co$SST, type="l")
plot(co$Year, co$menhadenYOY, type="l")
rm(list=ls())
library(MARSS)
## load the data
d <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/birdPA.csv", header=T, sep=",")
co <- read.table("C:/Users/mandy.karnauskas/Desktop/eBird/covars.csv", header=T, sep=",")
co <- co[which(co$Year <= max(d$Year) & co$Year >= min(d$Year)),]
## transpose data so time goes across columns
d[2:9] <- scale(d[2:9])
dat <- t(d[2:9])
## get number of time series
N_ts <- dim(dat)[1]
## get length of time series
TT <- dim(dat)[2]
## 'ZZ' is loadings matrix
Z_vals <- list("z11", 0, 0, 0, "z21", "z22", 0, 0, "z31", "z32", "z33", 0,
"z41", "z42", "z43", "z44", "z51", "z52", "z53", "z54", "z61",
"z62", "z63", "z64","z71", "z72", "z73", "z74","z81", "z82", "z83", "z84")
ZZ <- matrix(Z_vals, nrow = N_ts, ncol = 4, byrow = TRUE)
ZZ
## 'aa' is the offset/scaling
aa <- "zero"
## 'DD' and 'd' are for covariates
DD <- "zero"  # matrix(0,mm,1)
dd <- "zero"  # matrix(0,1,wk_last)
## 'RR' is var-cov matrix for obs errors
RR <- "diagonal and unequal"
## 'RR' is var-cov matrix for obs errors
RR <- "diagonal and equal"
RR <- "diagonal and equal"
## number of processes
mm <- 4
ZZ <- ZZ[,1:mm]
## 'BB' is identity: 1's along the diagonal & 0's elsewhere
BB <- "identity"  # diag(mm)
## 'uu' is a column vector of 0's
uu <- "zero"  # matrix(0,mm,1)
## 'CC' and 'cc' are for covariates
CC <- "zero"  # matrix(0,mm,1)
cc <- "zero"  # matrix(0,1,wk_last)
## 'QQ' is identity
QQ <- "identity"  # diag(mm)
## list with specifications for model vectors/matrices
mod_list <- list(Z = ZZ, A = aa, D = DD, d = dd, R = RR, B = BB,
U = uu, C = CC, c = cc, Q = QQ)
## list with model inits
init_list <- list(x0 = matrix(rep(0, mm), mm, 1))
## list with model control parameters
con_list <- list(maxit = 3000, allow.degen = TRUE)
## fit MARSS
dfa_1 <- MARSS(y = dat, model = mod_list, inits = init_list, control = con_list)
mm
RR
slr <- t(co[, "SLR", drop = FALSE])
men <- t(co[, "menhadenYOY", drop = FALSE])
sst <- t(co[, "SST", drop = FALSE])
sst[1:2] <- sst[3]
mod_list = list(m = 4, R = "diagonal and equal")
dfa_slr <- MARSS(dat, model=mod_list, form="dfa", z.score=FALSE,  control=con_list, covariates= slr)
dfa_men <- MARSS(dat, model=mod_list, form="dfa", z.score=FALSE,  control=con_list, covariates= men)
dfa_sst <- MARSS(dat, model=mod_list, form="dfa", z.score=FALSE,  control=con_list, covariates= sst)
ls
d <- read.table("C:/Users/mandy.karnauskas/Desktop/us-counties.csv", header=T, sep=",")
d <- read.table("C:/Users/mandy.karnauskas/Desktop/us-counties.csv", header=T, sep=",")
d <- read.table("C:/Users/mandy.karnauskas/Desktop/us-counties.csv", header=T, sep=",", quote=F)
version()
version
version
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
install.packages(c("tcltk2", "XML", "devtools"))
devtools::install_github("SWotherspoon/QPress", build_vignettes = TRUE)
writeLines('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', con = "~/.Renviron")
library(roxygen2)
getwd()
setwd("C:/Users/mandy.karnauskas/Desktop/completed_manuscripts/ESR_2017_update/FINAL_TIME_SERIES_DATA")
?roxygenise
roxygenise(load_code=NULL)
roxygenise(load_code=NULL)
roxygenise()
vignette("roxygen2")
Roxygen: list(markdown = TRUE)
roxygenise()
roxygenise()
Error in read.dcf(con)
read.dcf(system.file("DESCRIPTION", package = "pkgName", mustWork = TRUE))
library("Rmarkdown")
install.packages("Rmarkdown")
library("rmarkdown")
Yo
getwd()
